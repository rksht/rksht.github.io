<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on This</title>
    <link>https://rksht.github.io/posts/</link>
    <description>Recent content in Posts on This</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 May 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://rksht.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>What is a total derivative</title>
      <link>https://rksht.github.io/posts/total_deriv/</link>
      <pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/total_deriv/</guid>
      <description>Linear approximation We will only talk about scalar-valued functions.
First we learn about linear approximation - what it exactly is.
Look at a single-variable function $f : R \rightarrow R$. The linear approximation of this function at the point $x = a$, is defined as the function $L : R \rightarrow R$ such that
$L(x) = f(a) + f&amp;rsquo;(a) * (x - a)$
Linear part is $A(x) = f&amp;rsquo;(a)x$. So we could write it as $L(x) = f(a) + A(x - a)$</description>
    </item>
    
    <item>
      <title>Derivation an RNG following the cosine distribution</title>
      <link>https://rksht.github.io/posts/derivation_of_cosine_distrib/</link>
      <pubDate>Mon, 20 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/derivation_of_cosine_distrib/</guid>
      <description>Using the inversion method.
The CDF is
$$ G(\theta, \phi) = \frac{\sin^2\theta}{2\pi} (\phi+\pi) $$
We got two random variables that we need to sample $\theta$ and $\phi$.
First, as per the technique, we compute $G_{max} ≡ G(\theta, \phi_{max})$ . Noting that $\phi_{max} = \pi$ we compute $G(\theta,\pi) = \sin^2\theta$.
Now, if we generate a canonical random variable $r_j$, let $r_j = G(\theta_j,\pi)$, where $\theta_j$ stands for the sampled value of $\theta$.</description>
    </item>
    
    <item>
      <title>Radiance formulas</title>
      <link>https://rksht.github.io/posts/radiance_formulas/</link>
      <pubDate>Mon, 20 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/radiance_formulas/</guid>
      <description>Preliminary Differential solid angle = $dω = \sin{\theta} \space dθ \space dϕ$
A solid angle is an integral quantity. Multiple collections of directions can have the same solid angle measure.
 &amp;ldquo;Power&amp;rdquo; without any extra &amp;ldquo;per something&amp;rdquo; is not a super useful quantity.
Power entering or leaving a surface $\Phi$ is an integral quantity denoting the total power measured on the surface area of an object.
So we are indeed associating power with area.</description>
    </item>
    
    <item>
      <title>Go ramblings</title>
      <link>https://rksht.github.io/posts/go/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/go/</guid>
      <description>This is not inheritance.
type GitGudder interface { GitGud() } type BaseStruct struct { // whatever } func (b *BaseStruct) GitGud() { // meh } type MyStruct struct { BaseStruct number int }  This is not inheritance. Although MyStruct implements the GitGudder interface, the BaseStruct in MyStruct knows nothing about the other fields in MyStruct. So it truly is composition. The GitGud() method on BaseStruct takes a pointer to BaseStruct, not MyStruct.</description>
    </item>
    
    <item>
      <title>Haskell ramblings</title>
      <link>https://rksht.github.io/posts/haskell/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/haskell/</guid>
      <description>Some silly comments
  Terseness: Although it can be overdone, you can write terse yet readable code.
  Monads:
 Value producers with outgoing valves? Yes, &amp;ldquo;valves&amp;rdquo;. A type that implements a function called bind which should know how to pump values into a continuation? That&amp;rsquo;s about it    Monad transformers:
 A value producer that you get by connecting two or more value producers?    Do notation:</description>
    </item>
    
    <item>
      <title>Limit of a sequence (i.e. discrete limit)</title>
      <link>https://rksht.github.io/posts/limit_of_sequence/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/limit_of_sequence/</guid>
      <description>In all this discussion, variables $n$ and $k$ will be positive integers.
A sequence $S \equiv S(n)$ (denoted as $S_n$) where $n \in \mathbb{Z}^+$ is said to have a finite limit $a$ iff
$$ \forall d \in \mathbb{R}^+, (\exists k \in \mathbb{Z}, (\forall n &amp;gt; k, (|a - S_n| &amp;lt; d))) $$
From an adversary game point of view, no matter how small you choose d, you will find that $S_n$ never goes above $d$ after a certain point.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rksht.github.io/posts/dft/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/dft/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>