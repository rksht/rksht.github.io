<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on This</title>
    <link>https://rksht.github.io/posts/</link>
    <description>Recent content in Posts on This</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://rksht.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Workbook</title>
      <link>https://rksht.github.io/posts/workbook/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/workbook/</guid>
      <description>Conv Net notes F = the filter matrix I = the image matrix In 1D, if filter size is n (which should be odd) and we want to know the convolved output at location i. Then conv(i) = sum_{f = 0 to n-1} Filter[f] * Image[f - (n-1)/2 + i]
This is actually cross correlate op not quite convolution op.
How to set the neural net layer An observation - You want to find the grad of the global relative to the parameters of the sub-node functions.</description>
    </item>
    
    <item>
      <title>Code-like</title>
      <link>https://rksht.github.io/posts/code/</link>
      <pubDate>Mon, 29 Jun 2020 04:12:58 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/code/</guid>
      <description>C/C++ coding convention Indentation Indent using 4 spaces. 2 spacess is too small, and using tabs makes it difficult to line stuff up using a mixture of spaces and tabs.
Structs/classes Make them capitalized
struct LikeThis { };  Local variables, and member variables Make them snake cased.
LikeThis like_this;  Function names Make them snake cased too
void my_cool_function(int first, int second) {}  Macros Make them SCREAMING! You should prefer enums, and inline functions, and use macros only when there is no other way or they reduce verbosity a lot.</description>
    </item>
    
    <item>
      <title>Temp Notes</title>
      <link>https://rksht.github.io/posts/temp_notes/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/temp_notes/</guid>
      <description>The &amp;ldquo;GradGlobalWrtParams&amp;rdquo; operator The global function is $G$ and the node is $f$. We also denote the successors of $f$ as $succ(f)$.
Each such node as a list of parameters it depends on. The concatenated list of all parameters of all nodes form the parameters of $G$. Assume that gradient for $G$ is computable everywhere.
So, we have the gradient of $G$ like
$$ \nabla G = \langle \frac{\partial G}{\partial w_1}, \frac{\partial G}{\partial w_2}, \ldots \frac{\partial G}{\partial w_n} \rangle $$</description>
    </item>
    
    <item>
      <title>Derivation an RNG following the cosine distribution</title>
      <link>https://rksht.github.io/posts/derivation_of_cosine_distrib/</link>
      <pubDate>Mon, 20 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/derivation_of_cosine_distrib/</guid>
      <description>Using the inversion method.
The CDF is
$$ G(\theta, \phi) = \frac{\sin^2\theta}{2\pi} (\phi+\pi) $$
We got two random variables that we need to sample $\theta$ and $\phi$.
First, as per the technique, we compute $G_{max} ≡ G(\theta, \phi_{max})$ . Noting that $\phi_{max} = \pi$ we compute $G(\theta,\pi) = \sin^2\theta$.
Now, if we generate a canonical random variable $r_j$, let $r_j = G(\theta_j,\pi)$, where $\theta_j$ stands for the sampled value of $\theta$.</description>
    </item>
    
    <item>
      <title>Radiance formulas</title>
      <link>https://rksht.github.io/posts/radiance_formulas/</link>
      <pubDate>Mon, 20 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/radiance_formulas/</guid>
      <description>Preliminary Differential solid angle = $dω = \sin{\theta} \space dθ \space dϕ$
A solid angle is an integral quantity. Multiple collections of directions can have the same solid angle measure.
 &amp;ldquo;Power&amp;rdquo; without any extra &amp;ldquo;per something&amp;rdquo; is not a super useful quantity.
Power entering or leaving a surface $\Phi$ is an integral quantity denoting the total power measured on the surface area of an object.
So we are indeed associating power with area.</description>
    </item>
    
    <item>
      <title>Go ramblings</title>
      <link>https://rksht.github.io/posts/go/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/go/</guid>
      <description>This is not inheritance.
type GitGudder interface { GitGud() } type BaseStruct struct { // whatever } func (b *BaseStruct) GitGud() { // meh } type MyStruct struct { BaseStruct number int }  This is not inheritance. Although MyStruct implements the GitGudder interface, the BaseStruct in MyStruct knows nothing about the other fields in MyStruct. So it truly is composition. The GitGud() method on BaseStruct takes a pointer to BaseStruct, not MyStruct.</description>
    </item>
    
    <item>
      <title>Haskell ramblings</title>
      <link>https://rksht.github.io/posts/haskell/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/haskell/</guid>
      <description>Some silly comments
  Terseness: Although it can be overdone, you can write terse yet readable code.
  Monads:
 Value producers with outgoing valves? Yes, &amp;ldquo;valves&amp;rdquo;. A type that implements a function called bind which should know how to pump values into a continuation? That&amp;rsquo;s about it    Monad transformers:
 A value producer that you get by connecting two or more value producers?    Do notation:</description>
    </item>
    
    <item>
      <title>Limit of a sequence (i.e. discrete limit)</title>
      <link>https://rksht.github.io/posts/limit_of_sequence/</link>
      <pubDate>Sun, 12 Jan 2020 06:57:03 +0530</pubDate>
      
      <guid>https://rksht.github.io/posts/limit_of_sequence/</guid>
      <description>Limit of a sequence (i.e. discrete limit) In all this discussion, variables $n$ and $k$ will be positive integers.
A sequence $S \equiv S(n)$ (denoted as $S_n$) where $n \in \mathbb{Z}^+$ is said to have a finite limit $a$ iff
$$ \forall d \in \mathbb{R}_{\gt 0}, (\exists k \in \mathbb{Z}, (\forall n \gt k, (|a - S_n| \lt d))) $$
From an adversary game point of view, no matter how small you choose $d$ (without making it 0), you will find that the distance between $a$ and $S_n$ stays less than $d$ after a certain point.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rksht.github.io/posts/ntheory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/ntheory/</guid>
      <description>Number theoretic ideas Since we deal with large integers, the time complexity of the algorithms is expressed with respect to the number of bits of the input integers. Elementary operations like add, subtract, multiply and divide can be time-consuming enough when dealing with large integers, so it becomes relevant to measure how many bit operations are required by a number-theoretic algorithm. In this model, the schoolbook multiplication algorithm to mul two words requires a time O(b^2) where b is the word size.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://rksht.github.io/posts/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://rksht.github.io/posts/summary/</guid>
      <description>The tamper-proof nation
  Blockchain based transactions at every level
  Property (land, money, stock) exchanges
  Voting
  All transactions auditable using a query lang
  </description>
    </item>
    
  </channel>
</rss>
