<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Go ramblings - This</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Go ramblings" />
<meta property="og:description" content="This is not inheritance.
type GitGudder interface { GitGud() } type BaseStruct struct { // whatever } func (b *BaseStruct) GitGud() { // meh } type MyStruct struct { BaseStruct number int }  This is not inheritance. Although MyStruct implements the GitGudder interface, the BaseStruct in MyStruct knows nothing about the other fields in MyStruct. So it truly is composition. The GitGud() method on BaseStruct takes a pointer to BaseStruct, not MyStruct." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rksht.github.io/posts/go/" />
<meta property="article:published_time" content="2020-01-12T06:57:03+05:30" />
<meta property="article:modified_time" content="2020-01-12T06:57:03+05:30" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go ramblings"/>
<meta name="twitter:description" content="This is not inheritance.
type GitGudder interface { GitGud() } type BaseStruct struct { // whatever } func (b *BaseStruct) GitGud() { // meh } type MyStruct struct { BaseStruct number int }  This is not inheritance. Although MyStruct implements the GitGudder interface, the BaseStruct in MyStruct knows nothing about the other fields in MyStruct. So it truly is composition. The GitGud() method on BaseStruct takes a pointer to BaseStruct, not MyStruct."/>

	<link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="https://rksht.github.io/css/main.css" />

	<script
  type="text/javascript"
  async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

</head><body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rksht.github.io">This</a>
	</div>
	<nav>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Go ramblings</h1>
			<div class="meta">Posted on Jan 12, 2020</div>
		</div>
		

		<section class="body">
			<p>This is not inheritance.</p>
<pre><code>type GitGudder interface {
    GitGud()
}

type BaseStruct struct {
    // whatever
}

func (b *BaseStruct) GitGud() {
    // meh
}

type MyStruct struct {
    BaseStruct
    number int
}
</code></pre>
<p>This is not inheritance. Although <code>MyStruct</code> implements the <code>GitGudder</code>
interface, the <code>BaseStruct</code> in MyStruct knows nothing about the other fields
in MyStruct. So it truly is composition. The GitGud() method on <code>BaseStruct</code>
takes a pointer to <code>BaseStruct</code>, not <code>MyStruct</code>. You cannot &ldquo;downcast&rdquo; to
MyStruct, even though that <code>BaseStruct</code> is embedded in a <code>MyStruct</code>. So it
truly is composition. In C++ you can, although it is not safe without
dynamic_cast.</p>
<p>In fact you cannot provide default implementations of functions in an
interface that work in terms of some other functions in that same interface.
That&rsquo;s what abstract base classes do in other languages.</p>
<p>If you do want that, your only option is to make those functions that works by
using interface functions global. Look at
<a href="https://golang.org/pkg/io/.#WriteString">io.WriteString</a>. Any type that
implements <code>Writer</code>, will automatically be able to write <code>string</code>s instead of
<code>byte[]</code>. But <code>WriteString</code> is <em>not</em> a method of the <code>Writer</code> interface, it&rsquo;s
a global function.</p>
<p>What if you want to have a function that only depends on the <code>BaseStruct</code> and
the <code>GitGud</code>() interface?</p>
<p>You don&rsquo;t need to downcast, instead just use the GitGudder interface but
extend the interface to have a <code>GetBaseStruct</code> method:</p>
<pre><code>type GitGudder interface {
    GitGud()
    GitSuperGud()
    GetBaseStruct() *BaseStruct
}
</code></pre>
<p>You need to implement GetBaseStruct() for every specific struct that you want
to comply with GitGudder. Some chore.</p>
<pre><code>func UseBaseStructAndGitGudder(gud GitGudder) int {
    base := gud.GetBaseStruct()

    return base.GitGud() + gud.GetSuperGud() // Maybe your function is much more complex than just the `+` operator
}
</code></pre>
<h2 id="networking-with-code-that-looks-synchronous-but-is-actually-asynchronous">Networking with code that looks synchronous but is actually asynchronous</h2>
<p>Epoll is the event polling loop, and you are the event consumer. So you have
to write a loop that responds to event completion. If performance and number
of pthreads were not a concern, simply write</p>
<pre><code>while True:
    event = epoll()

    # get_event_context retrieves the event context from some global map of event -&gt; saved state
    context = get_event_context(event) 

    context.call_handler_for_event(event)
</code></pre>
<p>The context <em>is</em> the stack state needed to resume handling the connection or
whatever IO is being handled.</p>
<p>In Go, the net package implements the above loop. All blocking IO calls from
any goroutine are registered with the epoll and the context is basically the
goroutine state (registers like stack pointer, program counter, etc.)</p>
<p>Since this state saving and restoring is done by the Go runtime uniformly, we
don&rsquo;t need to identify which variables we need to save in the context for the
event we would be blocked on if we were using C and epoll directly. We write
code that looks synchronous as usual without manually saving state in between
blocking calls.</p>
<pre><code>func do_some_io() {
    f := dial(&quot;some address&quot;)
    d = f.recv()
    process_data(d)
    f.send(&quot;some value&quot;)
}
</code></pre>
<p>Now, dial, recv, and send are IO calls, that can block. But if we run the
whole function do_some_io in a goroutine, these IO calls are actually using
<em>non_blocking</em> system calls but the Go runtime is adding them to the epoll
events list and updating a map (well theoretically) of events to the current
state of the goroutine. On event completion (epoll returns), the runtime will
look up the associated goroutine for the event and resume the goroutine - with
the result of the IO call.</p>
<p>This is great because we are still using goroutines, not OS threads, for
handling connections. Even if there was only one OS thread we wouldn&rsquo;t block
(if we don&rsquo;t make any errors). This gives the illusion that just by doing IO
by spawing goroutines, it&rsquo;s as if we have numerous &ldquo;proper&rdquo; threads at our
disposal and we don&rsquo;t need to deal with the asynchronous nature of polling for
event completion, etc. by ourselves. P. cool.</p>
<p>So, to drive it home, it allows us to write code that looks like we are using
threads for each connection, while giving us the performance benefit event loop
design with a constant number of OS threads - usually that number of threads is
1 as you see in nodejs, python, etc.</p>

		</section>

		<div class="post-tags">
			
			
			
		</div>
	</article>
</main>
<footer>
<hr>⚡️
	2020  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>




</div>
    </body>
</html>
